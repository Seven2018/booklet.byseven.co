{"ast":null,"code":"import $ from \"jquery\";\nvar HORIZONTAL = \"horizontal\";\nvar VERTICAL = \"vertical\";\n\nvar getOrientationProps = function getOrientationProps(orientation) {\n  var horizontal = orientation === HORIZONTAL; // Properties with “X” are for cross orientation (relative to the scrollbar orientation)\n\n  return {\n    ORIENTATION: orientation,\n    SIZE: horizontal ? \"width\" : \"height\",\n    X_SIZE: horizontal ? \"height\" : \"width\",\n    OFFSET_SIZE: horizontal ? \"offsetWidth\" : \"offsetHeight\",\n    OFFSET_X_SIZE: horizontal ? \"offsetHeight\" : \"offsetWidth\",\n    CLIENT_SIZE: horizontal ? \"clientWidth\" : \"clientHeight\",\n    CLIENT_X_SIZE: horizontal ? \"clientHeight\" : \"clientWidth\",\n    INNER_X_SIZE: horizontal ? \"innerHeight\" : \"innerWidth\",\n    SCROLL_SIZE: horizontal ? \"scrollWidth\" : \"scrollHeight\",\n    SCROLL_POS: horizontal ? \"scrollLeft\" : \"scrollTop\",\n    START: horizontal ? \"left\" : \"top\",\n    X_START: horizontal ? \"top\" : \"left\",\n    X_END: horizontal ? \"bottom\" : \"right\"\n  };\n};\n\nvar floatingScrollProto = {\n  init: function init(container, orientation) {\n    var instance = this;\n    instance.orientationProps = getOrientationProps(orientation);\n    var scrollBody = container.closest(\".fl-scrolls-body\");\n\n    if (scrollBody.length) {\n      instance.scrollBody = scrollBody;\n    }\n\n    instance.container = container[0];\n    instance.visible = true;\n    instance.initWidget();\n    instance.updateAPI(); // recalculate scrollbar parameters and set its visibility\n\n    instance.addEventHandlers(); // Set skipSync flags to their initial values (because update() above calls syncWidget())\n\n    instance.skipSyncContainer = instance.skipSyncWidget = false;\n  },\n  initWidget: function initWidget() {\n    var instance = this;\n    var _instance$orientation = instance.orientationProps,\n        ORIENTATION = _instance$orientation.ORIENTATION,\n        SIZE = _instance$orientation.SIZE,\n        SCROLL_SIZE = _instance$orientation.SCROLL_SIZE;\n    var widget = instance.widget = $(\"<div class=\\\"fl-scrolls\\\" data-orientation=\\\"\".concat(ORIENTATION, \"\\\"></div>\"));\n    $(\"<div></div>\").appendTo(widget)[SIZE](instance.container[SCROLL_SIZE]);\n    widget.appendTo(instance.container);\n  },\n  addEventHandlers: function addEventHandlers() {\n    var instance = this;\n    var eventHandlers = instance.eventHandlers = [{\n      $el: instance.scrollBody || $(window),\n      handlers: {\n        // Don’t use `$.proxy()` since it makes impossible event unbinding individually per instance\n        // (see the warning at http://api.jquery.com/unbind/)\n        scroll: function scroll() {\n          instance.updateAPI();\n        },\n        resize: function resize() {\n          instance.updateAPI();\n        }\n      }\n    }, {\n      $el: instance.widget,\n      handlers: {\n        scroll: function scroll() {\n          if (instance.visible && !instance.skipSyncContainer) {\n            instance.syncContainer();\n          } // Resume widget->container syncing after the widget scrolling has finished\n          // (it might be temporally disabled by the container while syncing the widget)\n\n\n          instance.skipSyncContainer = false;\n        }\n      }\n    }, {\n      $el: $(instance.container),\n      handlers: {\n        scroll: function scroll() {\n          if (!instance.skipSyncWidget) {\n            instance.syncWidget();\n          } // Resume container->widget syncing after the container scrolling has finished\n          // (it might be temporally disabled by the widget while syncing the container)\n\n\n          instance.skipSyncWidget = false;\n        },\n        focusin: function focusin() {\n          setTimeout(function () {\n            return instance.syncWidget();\n          }, 0);\n        },\n        \"update.fscroll\": function updateFscroll(_ref) {\n          var namespace = _ref.namespace;\n\n          // Check event namespace to ensure that this is not an extraneous event in a bubbling phase\n          if (namespace === \"fscroll\") {\n            instance.updateAPI();\n          }\n        },\n        \"destroy.fscroll\": function destroyFscroll(_ref2) {\n          var namespace = _ref2.namespace;\n\n          if (namespace === \"fscroll\") {\n            instance.destroyAPI();\n          }\n        }\n      }\n    }];\n    eventHandlers.forEach(function (_ref3) {\n      var $el = _ref3.$el,\n          handlers = _ref3.handlers;\n      return $el.bind(handlers);\n    });\n  },\n  checkVisibility: function checkVisibility() {\n    var instance = this;\n    var widget = instance.widget,\n        container = instance.container,\n        scrollBody = instance.scrollBody;\n    var _instance$orientation2 = instance.orientationProps,\n        SCROLL_SIZE = _instance$orientation2.SCROLL_SIZE,\n        OFFSET_SIZE = _instance$orientation2.OFFSET_SIZE,\n        X_START = _instance$orientation2.X_START,\n        X_END = _instance$orientation2.X_END,\n        INNER_X_SIZE = _instance$orientation2.INNER_X_SIZE,\n        CLIENT_X_SIZE = _instance$orientation2.CLIENT_X_SIZE;\n    var mustHide = widget[0][SCROLL_SIZE] <= widget[0][OFFSET_SIZE];\n\n    if (!mustHide) {\n      var containerRect = container.getBoundingClientRect();\n      var maxVisibleCrossEnd = scrollBody ? scrollBody[0].getBoundingClientRect()[X_END] : window[INNER_X_SIZE] || document.documentElement[CLIENT_X_SIZE];\n      mustHide = containerRect[X_END] <= maxVisibleCrossEnd || containerRect[X_START] > maxVisibleCrossEnd;\n    }\n\n    if (instance.visible === mustHide) {\n      instance.visible = !mustHide; // We cannot simply hide the scrollbar since its scroll position won’t update in that case\n\n      widget.toggleClass(\"fl-scrolls-hidden\");\n    }\n  },\n  syncContainer: function syncContainer() {\n    var instance = this;\n    var SCROLL_POS = instance.orientationProps.SCROLL_POS;\n    var scrollPos = instance.widget[0][SCROLL_POS];\n\n    if (instance.container[SCROLL_POS] !== scrollPos) {\n      // Prevents container’s “scroll” event handler from syncing back again widget scroll position\n      instance.skipSyncWidget = true; // Note that this makes container’s “scroll” event handlers execute\n\n      instance.container[SCROLL_POS] = scrollPos;\n    }\n  },\n  syncWidget: function syncWidget() {\n    var instance = this;\n    var SCROLL_POS = instance.orientationProps.SCROLL_POS;\n    var scrollPos = instance.container[SCROLL_POS];\n\n    if (instance.widget[0][SCROLL_POS] !== scrollPos) {\n      // Prevents widget’s “scroll” event handler from syncing back again container scroll position\n      instance.skipSyncContainer = true; // Note that this makes widget’s “scroll” event handlers execute\n\n      instance.widget[0][SCROLL_POS] = scrollPos;\n    }\n  },\n  // Recalculate scroll width/height and container boundaries\n  updateAPI: function updateAPI() {\n    var instance = this;\n    var _instance$orientation3 = instance.orientationProps,\n        SIZE = _instance$orientation3.SIZE,\n        X_SIZE = _instance$orientation3.X_SIZE,\n        OFFSET_X_SIZE = _instance$orientation3.OFFSET_X_SIZE,\n        CLIENT_SIZE = _instance$orientation3.CLIENT_SIZE,\n        CLIENT_X_SIZE = _instance$orientation3.CLIENT_X_SIZE,\n        SCROLL_SIZE = _instance$orientation3.SCROLL_SIZE,\n        START = _instance$orientation3.START;\n    var widget = instance.widget,\n        container = instance.container,\n        scrollBody = instance.scrollBody;\n    var clientSize = container[CLIENT_SIZE];\n    var scrollSize = container[SCROLL_SIZE];\n    widget[SIZE](clientSize);\n\n    if (!scrollBody) {\n      widget.css(START, \"\".concat(container.getBoundingClientRect()[START], \"px\"));\n    }\n\n    $(\"div\", widget)[SIZE](scrollSize); // Fit widget size to the native scrollbar size if needed\n\n    if (scrollSize > clientSize) {\n      widget[X_SIZE](widget[0][OFFSET_X_SIZE] - widget[0][CLIENT_X_SIZE] + 1); // +1px JIC\n    }\n\n    instance.syncWidget();\n    instance.checkVisibility(); // fixes issue #2\n  },\n  // Remove a scrollbar and all related event handlers\n  destroyAPI: function destroyAPI() {\n    var instance = this;\n    instance.eventHandlers.forEach(function (_ref4) {\n      var $el = _ref4.$el,\n          handlers = _ref4.handlers;\n      return $el.unbind(handlers);\n    });\n    instance.widget.remove();\n    instance.eventHandlers = instance.widget = instance.container = instance.scrollBody = null;\n  }\n};\n\n$.fn.floatingScroll = function () {\n  var method = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"init\";\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (method === \"init\") {\n    var _options$orientation = options.orientation,\n        orientation = _options$orientation === void 0 ? HORIZONTAL : _options$orientation;\n\n    if (orientation !== HORIZONTAL && orientation !== VERTICAL) {\n      throw new Error(\"Scrollbar orientation should be either \\u201C\".concat(HORIZONTAL, \"\\u201D or \\u201C\").concat(VERTICAL, \"\\u201D\"));\n    }\n\n    this.each(function (index, el) {\n      return Object.create(floatingScrollProto).init($(el), orientation);\n    });\n  } else if (Object.prototype.hasOwnProperty.call(floatingScrollProto, \"\".concat(method, \"API\"))) {\n    this.trigger(\"\".concat(method, \".fscroll\"));\n  }\n\n  return this;\n};\n\n$(document).ready(function () {\n  $(\"body [data-fl-scrolls]\").each(function (index, el) {\n    var $el = $(el);\n    $el.floatingScroll(\"init\", $el.data(\"flScrolls\") || {});\n  });\n});","map":null,"metadata":{},"sourceType":"module"}